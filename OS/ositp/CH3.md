### ch 3 컴퓨터 시스템의 동작 원리
#### 컴퓨터 시스템 구조
- 컴퓨터 내부장치인 CPU, 메모리와 컴퓨터 외부 장치인 디스크, 키보드, 마우스, 모니터, 너트워크 장치
- 외부 장치에서 내부장치로 데이터를 읽어(입력 input)와 각종 연산을 수행후, 그 결과를 외부장치로 다시 내보내는(출력 output) 방식으로 업무를 처리
- 하드웨어 장치에는 컨트롤러라는 것이 붙어있다.
- 컨트롤러란? 각 하드웨어 장치마다 존재하면서 이들을 제어하는 작은 CPU
- 운영체제의 모든 코드를 다 메모리 상주 메모리 낭비 -> 운영체제 중 항상 메모리에 올라가 있는 부분은 전체 운영체제 중 행심적인 부분 한정(커널)
#### CPU 연산과 I/O연산
- 입출럭장치들의 I/O연산 - 입출력 컨트롤러
- 컴푸터 내에서 수행되는 연산 - 메인 CPU
- 입출럭 장치와 메인 CPU는 동시 수행 가능
- 컨트롤러는 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리 - 로컬버퍼
- 로컬버퍼에 데이터가 입시 저장 메모리 전달
- 로컬버퍼로 읽어 오는 일 - 컨트롤러 담당
- 로컬버퍼로 읽어오는 작업이 끝났는지 컨트롤러가 인터럽트를 발생시켜 CPU에 보고
- 인터럽트는 컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방법
- CPU는 명령 하나를 수행할 때마다 인터럽트 발생했는지 확인
- 인터럽트는 키보느 입력 혹은 요청된 디스크 입출력 작업 완료 등 CPU에 알려줄 필요가 있는 이벤트가 일어난 경우 컨트롤러가 발생
#### 인터럽트의 일반적인 기능
- 운영체제 커널에는 인터럽트가 들어왔을 때 해야 할일이 미리 다 프로그래밍되어 그 코드가 보관
- 각종 하드웨어 및 소프트웨어 자원 관리뿐 아니라 사용자 프로그램에 필요한 서비스 제공 - 운영체제가 할일 운영체제의 개발자가 미리 프로그래밍해서 커널 내에 포함
- 그 중 한 가지 인터럽트 처리 루틴 - 다양한 인터럽트에 대해 각각 처리해야 할 업무들을 정의
- 디스크 컨트롤러가 인터럽트를 발생 - 디스크의 로컬버퍼에 있는 내용을 사용자 프로그램의 메모리로 전달
- 하드웨어 인터럽트/소프트웨어 인터럽트 - CPU의 서비스가 필요한 경우, CPU 옆에 있는 인터럽트 라인에 신호를 보내 알려주는 방식 동일
- 하드에어 장치가 CPU의 인터럽트 라인을 세팅/소프트웨어가 CPU의 인터럽트 라인을 세팅
- 인터럽트 벡터 - 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키고 있느 자료구조
- 실제 처리해야 할 코드는 인터럽트 처리루틴 또는 인터럽트 핸들러
- 인터럽트 처리 전에 수행중인 작업이 무엇이었는지 반드시 저장 이러한 정보를 저장하기 위해 장소를 운영체제에 별도로 가진다
- 통상 인터럽트 = 하드웨어 인터럽트
- 소프트웨어 인터럽트는 트랩이라는 용어로 불린다
- 소프트웨어 인터럽트 예로는 예외사황, 시스템 콜
- 예외사황 - 비정상적인 작업 시도, 권한이 없는 작업을 시도 할때 이에 대한 처리를 위해 발생시키는 인터럽트
- 시스템 콜 - 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을때 운영체제에 서비스를 요청하는 방법
- 본인이 직접 입출력을 수행하는 코드를 자성하는 것이 아니라 이미 존재하는 커널의 코드를 호출해서 처리
- 프로그램 코드가 직접 인터럽트 라인을 세팅하는 명령를 실해하여 인터럽트를 발생시킨 후 제어권이 넘어가게 되므로 이들도 넓은 의미에 인터럽트 범주
#### 인터럽트 핸들링
- 인터럽트 핸들링이란? 인터럽트가 발생한 경우 처리해야 할 일의 절차
- CPU에서 명령이 실핼될 때에는 CPU 내부에 있는 임시 기억장치인 레지스터에 데이터를 읽거나 쓰면서 작업 이때 인터럽트 발행해 새로운 명령을 실행하면 기존 레지스터값들이 지워지게 되므로 CPU내의 이러한 상태를 저장
- 운영체제는 현재 시스템 내에서 실행되는 프로그램들 관리를 위해 '프로셋스 제어블록(PCB)'라는 자료구조를 둔다
- PCB는 해당 프로그램의 어느 부분이 실행 중인지 저장 구체적으로 프로그램이 실행 중이던 코드의 메모리 주소와 레지스터값, 하드웨어 상태 등 저장
- 오늘날 컴푸터의 운영체제는 인터럽트가 발생할 때에만 실행 그럼에도 불구하고 운영체제는 컴퓨터 내의 모든 하드웨어 및 소프트웨어 자원을 체계적이고 효율적으로 관리
#### 입출력 구조
- 입출력(I/O)이란? 컴퓨터 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고받는 것을 말한다.
- 동기식 입출력/비동기실 입출력
- 동기식 입출력 - 어떤 프로그램이 입출력을 요청을 했을 때 입출력 작업이 완료된 후에야 프로그램이 후속 작업을 수행할 수 있는 방식을 말한다.
- 입출력이 완료되어 인터럽트를 통해 그 사실이 전달된 후에야(다음 명령을 수행하지 않고 기다린다) CPU의 제어권이 프로그램으로 넘어가 다음 명령 수행
- 동기식 입출력에서 CPU는 입출력 연산이 끝날 때까지 인터럽트를 기다리며 자언을 낭비
- 입출력 작업이 완료될 때까지 CPU가 아무일도 하지 못하게 하기 때문에 자원의 낭비 초래
- 운영체제는 프로그램을 몇 가지 상태로 나누고 입출력 중인 프로그램의 경우 봉쇄 상태로 전환
- 봉쇄 상태의 프로그램에게는 CPU를 할당하지 않고, CPU 할당 시 곧바로 명령을 수행할 수 있는 프로그램에만 CPU를 할당
- 동기식 입출력에서는 입출력 요청의 동기화를 위해 장치별 큐(queue)를 두어 요청한 순서대로 처리할 수 있도록 한다.
- 큐에 있는 순서대로 처리하는 대신 요청들을 모으고 처리 순서를 바꾸어 입출력의 **효율성**을 높일 수 있는데, 이러한 경우 동기화를 보장하기 위한 별도의 방안이 마련되어야 한다.
- 입출력을 요청한 프로그램은 입출력동안 다음 명령을 수행할 수 없기 때문에 CPU 낭비 다른 프로그램에게 CPU를 양도함으로써 동시에 다수의 입출력연산 
- 다수의 프로그램이 동시에 입출력 연산을 요청하는 경우 동기성을 보장하기 위해 장치마다 큐를 두어 요청된 순서대로 처리
- 장치마다 큐헤더가 존재하고 각 장치별로 입출력 수행 순서를 지켜 주기 위한 큐를 관리
- CPU의 수행 속도에 비해 컨트롤러의 수행 속도나 장치 자체의 작업 수행 능력은 매우 떨어진다
- 입출력이 완료될 때까지 CPU가 아무 일도 못하게 하는 것이 아니라, 입출력과 관련 없는 프로그램을 수행, 요청된 입출력 연산이 완료되면 CPU에서 입출력이 완료되었음을 알려주는 방식 진행
- 비동기식 입출력은 입출력 연산을 요청한 후에 연산이 끝나기를 기다리는 것이 아니라 CPU의 제어권을 입출력 연산을 호출한 프로그램에게 곧바로 다시 부여하는 방식
- 비동기식 입출력에서는 데이터와 관련 없는 작업을 먼저 수행하고 읽어오는 데이터가 반드시 필요한 작업을 입출력 완료 후 수행
- 입출력 요청이 디스크에서 읽어오는 요청이 아니라 디스크에 쓰는 요청이라면 쓰기 작업이 완료되기 전에도 다음 명령 수행할 수 있으므로 비동기식 입출력이 사용될 수 있다.
- 일반적으로는 운영체제에게 입출력 요청을 할 경우 해당 프로그램의 입출력이 완료될 때까지 그 프로그램을 봉쇄시키는 동기식 입출력을 사용
- 운영체제는 장치별로 입출력 처리를 기다리는 프로세스를 줄 세워 관리함으로써 동기성을 보장
#### DMA
- 모든 메모리 접근 연산이 CPU에 의해서만 이루어질 경우 입출력 장치가 메모리 접근을 원할 때마다 인터럽트에 의해 CPU의 업무가 방해를 받게 되어 CPU사용의 효율성이 떨어지는 문제점 발생
- 비효율성 극복을 위해 CPU 이외에 메모리 접근이 가능한 장치를 두는 경우 이러한 장치 DMA
- 로컬버퍼에서 메모리로 읽어오는 작업을 CPUㅏ 담당하는 것이 아니라 DMA가 대행
- DMA는 바이트 단위가 아니라 블록이라는 큰 단위로 정보를 메모리로 읽어온 후에 CPU에 인터럽트 발생시켜서 해당 작업의완료를 알려준다
- CPU에 발생하는 인터럽트의 빈도를 줄여 좀 더 효율적으로 관리 입출력 연산 빠르게 수행
#### 저장장치의 구조
- 주기억장치/보조기억장치
- 주기억장치 - 보통 메모리 휘발성의 RAM
- 보조기억장치 - 비휘밠성 마그네틱 디스크 주로 사용(플래싯 메모리, CD, 마그네틱 테이프)
- 보조이걱장치 용도 두가지
  - 파일 시스텀용 : 전원이 나가도 유지해야 할 정보가 있으면 그것을 파일 형태로 보조기억장치에 저장
  - 메모리의 연장 공간인 스왑영역용 : 메모리는 크기가 한정되고, 가격이 상대적으로 비싼데다 용량이 적은 경우가 대부분
  - 스왑 영역으로는 하드디스크가 널리 사용
  - 하드디스크 여러 개의 마그네틱 원판들이 있고, 암(arm)이 이동하며 원판에 저장된 데이터를 일고 쓰는 방식으로 동작
  - 디스크 원판 표면 트랙(track)으로 나뉘고, 각 트랙은 섹터로 나뉜다.(섹터에 최소한의 단위 정보 저장)
#### 저장장치의 계층 구조
- 빠른 저장장치부터 느린 저장장치까지 단계적 계층 구조
- CPU 내부에 존재하는 레지스터부터 캐시 메모리, 메인 메모리등의 휘발성 저장장치로 구성
- 메인 메모리보다 아랫부분을 구성하는 저장장치 계층은 전원이 나가도 지워지지 않는 비휘발성 저장장치
- 당장 필요한 정보만 선별적으로 저장하면 하위에 있는 큰 용량의 저장장치를 가지고 있는 것과 비슷한 성능 효과
- 캐싱 기법이란? 상대저으로 용량이 적은 빠른 저장장치를 이용해 느리 저장장치의 성능을 향상시키는 총체적 기법
- 상대저으로 느린 저장장치에 있는 내용 중 당장 사용되거나 빈번히 사용될 정보를 빠른 저장장치에 선별적으로 저장 두 저장장치 사이 소도 완충
- 빈번히 사용될 정보를 빠른 저장장치에 저장 곧바로 찾을 수 있는 경우가 많아져 전제적인 성능 향상
- 컴푸터 내의 데이터나 프로그램을 구성하는 모든 부분이 균일하게 사용되는 것이 아니라 일부분만 집중적으로 사용되고 틍정 부분은 거의 사용되지 않기 때문
- 캐싱 기법을 컴푸터 시스템 내의 다양한 저장장치 계층에서 활용함으로써 적은 용량의 상위 저장장치만으로 대부분의 경우 빠른 수행 속도의 성능을 얻어낸다
#### 하드웨어의 보안
- 다중 프로그래밍 환경 - 프로그램이 다른 프로그램의 실행을 방해하거나 프로그램 간에 충돌을 일으키는 문제를 막기 위해 하드웨어에 대한 각종 보안 기법 필요
- 커널모드/사용자모드
- 커널모드 - 운영체제가 CPU의 제어권을 가지고 운영체제 코드 실행(모든 종류의 명령을 다 실행)(인터럽트/시스템콜/예외사황 발생시)
- 사용자모드 - 일반 사용자 프로그램이 실행되며 제한적인 명령만 수행
- 시스템의 중요한 영향을 미치는 연상(중요한 정보에 접근해 위험한 상황을 초래할 수 있는 연산)은 커널모드에서만 실행 가능하도록 함으로써 하드웨어의 보안 유지
- 컴퓨터 시스템은 CPU 내부에 모드비트를 두어 사용자 프로그램 감시(하드웨어적인 지원)
- 모드비트 0 - 커널모드 / 모드비트 1 - 사용자 모드
- 사용자는 프로그램이 수행되다가 하드웨어 접근등 보안이 필요한 명령을 수해해야 할 경우 '시스템 콜'을 통해 운영체제가 대신해줄 것을 요청
- 시스템 보안과 관련된 명령들 = 특권명령(커널모드에서 운영체제에 의해서만 수행)
- 각종 하드웨어 장치에서 보안이 유지되는 방식
  - **디스크**사용자 프로그램이 디스크에 저장된 파일에 자유롭게 접근 할 수 있다면 보안상 문제 발생 모든 입출력은 특권명령으로 규정
  - 입출력을 하고 싶으면 시스템 콜로 운영체제에 요청 운영체제가 CPU를 할당받고 인터럽트 벡터의 특정 위치를 통해 해당 인터럽트 처리루팅으로 이동
  - 운영체제는 입출력 요청이 올바른 요청인지 확인 후 입출력을 실행 파일에 대한 보안 유지
#### 메모리 보안
- 여러 프로그램이 메모리에 동시에 올라가서 실행되기 때문에 하나의 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범
- 메모리 주소 참조 연산을 잘못 사용해 다른 사용자 프로그램의 메모리 영역이나 운영체제 커널이 위치한 영역을 참조하려는 시도
- 따라서 적어도 인터럽트 벡터와 인터럽트 처리루틴이 있는 곳은 각별한 보안이 필요
- 사용자 프로그램이 특권명령을 보안성이 침해되는 이상한 명령으로 변환할 가능성 차단
- 2개의 레지스터를 사용해서 프로그램이 접근하려는 메모리 부분이 합법적인지 체크
- 기준 레지스터/한계레지스터
- 기준레지스터 - 어떤 프로그램이 수행된는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리상의 가장 작은 주소 보관
- 한계레지스터 - 그 프로그램이 기준 레지스터값부터 접근할 수 있는 메모리의 범위를 보관
- 사용자 프로그램은 기준 레지스터에 있는 주소부터 기준 레지스터 + 한계 레지스터값 사이의 주소 영역에만 접근 가능
- 범위 안에 없으면 불법적인 메모리 접근 -> 예외사황 소프트웨어적인 인터럽트 발생 프로그램강제 종료
- 2개의 레지스터를 이용하는 방법은 하나의 프로그램이 메모리의 한 영역에 연속적으로 위치하는 단순화된 메모리 관리 기법을 사용하는 경우 한정된 설명
- 7장 다양한 메모리 관리 기법 - 페이징 기법
- 2개의 레지스터뿐 아니라 다른 하드웨어의 자원을 통해서 연속적이지 않은 공간에 프로그램이 위치하는 좀 더 현실적인 메모리 관리 및 보호 기법 필요
- 메모리 접근 연산은 특권명령이 아니다 다만 사용자 프로그램이 메모리에 접근하기 전에 하드웨어적으로 그 접근이 합법적인지를 체크하여 메모리 보호 - 올바르지 않은 접근 시도로부터 메모리를 보호하기 위해서는 기준 레지스터와 한계 레지스터의 값을 세팅하는 연산은 특권명령 규정
- 기준 레지스터와 한계 레지스터의 값을 직접 변경할 수 있다면 메모리에 무제한 접근하는 것이 가능
- 커널모드에서는 메모리에 무제한으로 접근 가능
- 운영체제가 2개의 레지스터값을 직접 세팅 사용자 프로그램이 임의로 변경 불가
#### CPU 보호
- CPU각 하나의 프로그램에 의해 독점되는 것을 막기 위해 운영체제는 타이머라는 하느웨어를 사용
- 타이머는 정해진 시간이 지나면 인터럽트를 발생시켜 운영체제가 CPU의 제어권을 획득할 수 있도록 하는 역할 수행
- 타이머에 의해 발생되는 인터럽트 처리루틴의 역할은 지금 CPU를 점유하고 명령을 실행 중인 프로그램으로부터 CPU를 빼앗아 다른 프로그램에게 CPU를 이양
- 타이머는 일정한 시간 단위로 세팅 매 클릭 틲 때마다 1씩 감소 그리고 타이머가 0이 되는 순간 인터럽트가 발생
- 타이머 값을 세팅하는 명령을 로드타이머 특권명령에 속한다
- 타이머는 시분할 시스템에섯 현재 시간을 계산하기 위해서도 사용
- 시분할 시스템이란? 여러 프로그램이 CPU의 시간을 조금씩 나누어 사용하는 시스템
- 우리가 사용하는 대부분의 컴퓨터가 바로 시분할 시스템
#### 시스템 콜을 이용한 입출력 수행
- 사용자 프로그램이 디스크의 파일에 데이터를 쓰거나 디스크의 파일로부터 데이터를 읽어오는 행위, 키보드로부터 입력을 받거나 수행 결과를 화면에 출력하는 행위, 키보드로부터 입력을 받거나 수행 결과를 화면에 출력하는 행위 등은 모두 특권명령인 입출력 명령에 해당
- 사용자 프로그램이 직접 수행할 수 없다 입출력 명령은 운영체제 코드에 구현 사용자 프로그램은 직접 입출력을 수행하는 대신 운영체제에게 시스템 콜이라는 서비스 대행 요청을 하여 입출력을 수행
- 시스템 콜은 일종의 소프트웨어적인 인터럽트로서 사용자 프로그램이 시스템 콜을 할 경우 트랩이 발생해 CPU의 제어권이 운영체제로 넘어가게 된다.
