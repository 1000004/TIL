### CPU 스케줄링
* CPU는 프로그램의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙처리이다
* 프로그램이 시작되어 메모리에 올가가면 프로그램 카운터라는 이름의 레지스터가 현재 CPU에서 수행할 코드의 메모리 주소값을 가지고 있게 된다.그러면 CPU는 프로그램 카운터가 가르키는 주소의 기계어 명령을 하나씩 수행
* CPU는 일반적으로 한 시스템 내에 하나씩밖에 없으므로 여러 프로그램이 동시에 수행되는 시분할 환경에서 매우 효율적으로 관리되어야 하는 자원
* 프로그램 실행과 관련된 기계어 명령 - CPU 내에서 수행되는 명령, 메모리 접근을 필요로 하는 명령, 입출력을 동반하는 명령
* CPU 내에서 수행되는 수행되는 명령의 예로 ADD명령
    * ADD 명령은 CPU 내의 레지스터에 있는 두 값을 더해 레지스터에 저장하는 명령
    * CPU 내에서 수행되므로 명령의 수행 속도가 매우 빠르다
* 메로리 접근을 수행하는 명령 Load 명령과 Store 명령
    * Load 명령은 메모리에 있는 데이터를 CPU로 읽어드리는 명령
    * Store 명령은 CPU에서 계산된 결과값을 메몸리에 저장하는 명령
    * 메모리를 접근하는 명령이 비록 CPU 내에서 수행되는 명령보다는 시간이 오래 소요되지만 비교적 짧은 시간에 수행
* CPU 내에서 일어나는 명령이나 메모리를 접근하는 명령은 사용자 프로그램이 직접 실행할 수 있는 일반명령
* 입출력을 수반하는 명령은 CPU나 메모리 접근 명령에 비해 대단한 오랜 시간이 소요
* 컴퓨터 시스템에서는 모든 입출력 명령을 특권명령으로 규정해 사용자 프로그림이 직접 수행할 수 없도록 하고 운영체제를 통해 서비스를 대행
* 사용자 프로그램이 수행되는 과정은 CPU작업과 I/O 잡겅의 반복(일종의 사이클 CPU와 I/O장치라는 상이한 자원 번갈아 사용하면서 프로그램 수행)
* 레지스터간의 연산으로 구성된 ADD명령이나 메모리 접근 명령 등은 프로그램이 CPU를 가지고 수행 빠른 명령
* I/O 요청시 CPU의 제어권 운영체제 커널로 넘어가고 상대적 매우 느린 입출력 장치의 접근 필요
* 프로그램 수행은 서로다른 두 단계의 조합
  * 첫째는 사용자 프로그램이 CPU를 가지고 빠른 명령을 수행하는 일련의 단계
  * I/O 요청이 발생해 커널에 의해 입출력 작업을 진하는 비교적 느린 단계
  * **전자는 CPU 버스트**,**후자는 I/O 버스트**
* CPU 버스트 : 프로그램이 I/O를 한 번 수행한 후 다름 번 I/O를 수행하기까지 직접 CPU를 가지고 명령을 수행하는 일련의 작업
* I/O 버스트 : I/O작업이 요청된 후 완료되어 다시 CPU 버스트로 돌아가기까지 일어나는 일련의 작업
* 각 프로그램마다 CPU 버스트와 I/O 버스트가 차지하는 비율이 균일하지 않다
* 이와 같은 기준으로 프로세스를 크게 **I/O 바운드 프로세스**, **CPU 바운드 프로세스**
* I/O 바운트 프로세스는 I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스
* CPU 바운드 프로세스는 I/O 작업이 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스를 말한다
* I/O 바운트 프로세스 - 대화형 프로그램(짧은 CPU 버스트 다수)
* CPU 바운드 프로세스 - 계산 위주의 프로그램(소수의 긴 CPU 버스트)
* CPU 스케줄링은 이와 같이 CPU를 사용하는 패턴이 상이한 여러 프로그램이 동일한 시스템 내부에서 함께 실행되기 때문에 필요
* 시분할 시스템에서는 이와 같이 CPU버스트가 균일하지 않은 다양한 프로그램이 공존하므로 효율적인 CPU스케줄링 기법이 반드시 필요
* 컴퓨터 시스템 내에서는 수행되는 프로세스의 CPU 버스트를 분석해보면 대부분의 경우 짧은 CPU 버스트를 가지며, 극히 일부분만 긴 CPU 버스트를 가진다
* 즉, 프로세스들의 CPU 버스트 분포는 다수의 짧은 CPU 버스트와 소수의 긴 CPU 버스트로 구성
* CPU 버스트가 짧은 프로세스는 대부분 대화형 작업으로 사용자와 인터랙션을 해가며 프로그램을 수행
* 사용자에세 입력을 받아 CPU 연산으 수행하고 그 결과를 다시 출력하는 작업을 수행
* 이러한 작버을 수행하는 프로세스는 CPU의 빠른 서비스가 필요 -> 대화형 작업이므로 사용자에 대한 빠른 응답이 중요
* CPU 스케줄링을 할 때 CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 사용할 수 있도록 하는 스케줄링이 필요
* CPU 스케줄링 시 I/O 바운드 프로세스의 우선순위를 높에주는 것이 바람직하다
* 이러한 스케줄링은 대화형 프로세스의 빠른 응답성 제공 외에 I/O 장치의 효율성을 높이는 효과
* I/O바운드 프로세스에게 먼저 CPU를 할당할 경우 CPU를 잠깐만 사용한 후 곧바로 I/O 작업을 수행할 수 있으므로 I/O 장치의 이용률이 높아지지 때문
* CPU 바운드 프로세스에게 먼저 CPU를 할당한다면 그 프로세스가 CPU를 다 사용할 때까지 I/O 바운드 프로세스는 응답시간이 길어질 뿐 아니라 해당 I/O 장치도 그 시간 동안 작업을 수행하지 않는 휴면 상태가 되기 때문에 비효율적
#### CPU 스케줄러
* CPU 스케줄러란? 준비 상태에 있는 프로세스들 중 어떠한 프로세스에서 CPU를 할당할지 결정하는 운영체제 코드
* CPU 스케줄러가 호출되면 CPU 스케줄러는 준비 큐에서 CPU를 기다리는 프로세스 중 하나를 선택해 CPU를 할당
* CPU 스케줄링이 필요한 경우
   * (1) 실행 상태에 있던 프로세스가 I/O 요청 등에 의해 봉쇄(bocked) 상태로 바뀌는 경우
   * (2) 실행 상태에 있는 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 바뀌는 경우
   * (3) I/O 요청으로 봉쇄 상태에 있던 프로세스의 I/O 작업이 완료되어 인터럽트가 발생하고 그 결과 이 프로세스가 종료되는 경우
   * (4) CPU에서 실행 상태에 있는 프로세스가 종료되는 경우
* 비선점형 : CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 빼앗기지 않는 방법
* 선점형 : 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있는 스케줄링 방법
* CPU를 빼앗는 방법
* 할당량(time quantum)을 부여한 후 타이머 인터럽트를 발생시키는 방법이 대표적
* (1),(4)가 비선점형 스케줄링의 예
* (2),(3)은 선점형 스케줄링의 예
* (3)은 이번에 I/O 작업이 완료된 프로세스가 인터럽트 당한 프로세스보다 우선순위가 높아, 인터럽트 처리 후 직전에 수행되던 프로세스에게 CPU를 다시 할당하는 것이 아니라 문맥교환을 통해 I/O가 완료된 프로세스에게 CPU를 할당하는 경우
#### 디스페처
* 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드를 **디스페처(dispatcher)**
* 디스페처는 현재는 현재 수행 중이던 프로세스의 문맥(context)을 그 프로세스의 PCB에 저장하고, 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 넘기는 과정을 수행
* 사용자 프로그램은 복원된 문맥 중 프로그램 카운터로부터 현재 수행할 주소를 찾을 수 있게 된다, 디스페저가 하느이 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간을 **디스페처 지연시간(dispatch latency)**
* 디스페처 지연시간의 대부분은 문맥교환 오버헤드
#### 스케줄링의 성능 평가
* 스케줄링 기법의 성능을 평가하기 위해 여러 지표
* 시스템 관점의 지표
   * CPU 이용률(CPU utilization) - 전체 시간 중에서 일을 한 시간의 비율
      * CPU는 대부분의 시스템에 하나만 존재하는 고비용의 자원이므로 CPU의 이용률은 시스템 전체의 성능과 밀접하게 관련
      * CPU가 일을 하지 않고 휴면(idle) 상태에 머무는 시간을 최대한 줄인는 것이 **스케줄링의 중요한 목표**
   * 처리량 - 주어진 시간동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지(CPU 버스트를 완료한 프로세스 개수)
      * CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 할당하는 것이 유리
* 사용자 관점의 지표
   * 소요시간 - 흐로세스각 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간
      * 준비 큐에서 기다린 시간과 실제로 CPU를 사용한 시간의 합
      * 프로그램이 시작해서 종료하기까지 걸리는 시간 아님, 프로그램이 시작해서 종료까지 CPU 버스트는 여러 차례 있을 수 있다 
   * 대기시간 - CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합
      * 시분할 시스템에서는 일반적으로 타이머를 이용해서 하나으 프로세스가 CPU를 연속으로 사용할 수 있는 시간을 제한
   * 응답시간 - 프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간
      * 응답시간은 대화형 시스템에 적합한 성능 척도로서 사용자 입장에서 가장 중요한 성능 척도
   * (기다린 시간과 관련된 지표)
