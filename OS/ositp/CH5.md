### ch5 프로세스 관리
#### 프로세스의 개념
* 디스크에 실행파일 형태로 존재하던 프러그램이 메모리에 올라서 실행되기 시작하면 비로소 생명력을 갖는 프롯세스
* 잡(job)이라는 용어와 프로세스를 혼용해 사용
* 프로세스의 문맥이란? 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 의미
* CPU를 다시 획득해 명령의 수행을 재개하는 시점이 되면 이전의 CPU 보유 시기에 어느 부분까지 명령을 수행했는지 직전 수행 시점의 정확한 상태 재현 필요
* 이때 정확한 재현을 위해 필요한 정보가 바로 프로세스의 문맥
* 프로세스의 문맥은 그 프로세스의 주소 공간(코드, 데이터, 스택 상태)을 비롯해 레지스터에 어떤 값을 가지고 있었는지와, 시스템콜 등을 통해 커널에서 수행한 일의 상태, 그 프로세스에 관해 커널이 관리하고 있는 각종 정보 등을 포함
* 프로세스의 문맥을 크게 ㅅ세가지
  * 하드웨어 문맥 : CPU의 수행 상태를 나타내는 것으로 프로그램 카운터 값고가 각종 레지스터에 저장하고 있는 값
  * 프로세스의 주소 공간 : 코드, 데이터, 스택으로 구성되는 자긱 자신만의 독자적인 주소 공간, 프로세스 주소 공간은 그 프로세스의 문맥을 결정 짖는 중요한 요소
  * 커널상의 문맥 : 운영체제는 프로세스를 관리하기 위한 자료구조를 유지 PCB와 커널스택이 이에 해당 프로세스의 문맥을 구성하는 중요
#### 프로세스의 상태
* 프로세스의 상태 실행, 준비, 봉쇄
* 실행 상태 : 프로세스가 CPU를 보유하고 기계어 명령을 실행학고 있는 상태
* 준비 상태 : 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태
* 봉쇄 상태 : CPU를 할당받더라도 당장 명령을 실행할 수 없는 프로세스의 상태
* 프로세스의 상태를 구분하는 이유는 컴퓨터의 자원을 효율적으로 관리하기 위함
* 프로세스 생성중이거나 종류중인 일시적 상태 시작(new) 상태, 완료(terminated) 상태
* 시작상태는 프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메로리 획득을 승인 받지 못한 상태
* 완료 상태는 프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리되지 못한 상태
* 실행시킬 프로세스를 변경하기 위해 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정을 문맥교환
* CPU 제어권을 가진 프로세스가 입출력을 위해 봉쇄상태가 되면서 준비 상태에 있는 프로세스 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 과정 : CPU 디스페치
* 비록 인터럽트 처리루틴이 직전에 실행중이던 프로세스와는 무관한 업무를 담고 있기는 하지만 인터럽트 처리를 우리는 편의상 직전 프로세스의 문맥에서 실행된 것으로 간주
* 경우에 따라서는 인터럽트 당한 프로세스에게 CPU를 다시 할당하지 않고, 입출력이 완료된 프로세스가 더 우선순위가 높은 프로세스인 경우 문맥교환을 통해 CPU 제어권을 이양
#### 프로세스 제어블록
* 프로세스 제어블록(PCB)이란? 운영체제가 시스템내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료 구조
* PCB 구성 요소
  * 프로세스의 상태 - CPU를 할당해도 되는지 여부를 결정하기 위해 필요
  * 프로그램의 카운터의 값 - 다음에 수행할 명령의 위치를 가리킨다
  * CPU 레지스터의 값 - CPU 연산을 위해 현 시점에 레지스터에 어떤값을 저장하고 있는지 나타낸다.
  * CPU 스케줄링 정보,메모리 관리 정보 - 각각 그 프로세스의 CPU 스케줄링과 메모리 할당을 위해 필요한 정보
  * 자원 사용 정보 - 사용자에게 자원 사용 요금을 계산해 청구하는 등의 용도로 사용
  * 입출력 상태 정보 - 프로세스가 오픈한 파일 정보 등 프로세스의 입출력 관련 상태 정보
#### 프로세스를 스케줄링하기 위한 큐
* 준비 큐에 프로세스를 줄 세우는 방법은 CPU 스케줄링 방법에 따라 달라진다. 자세히[6장](https://github.com/yeRim650/TIL/blob/main/OS/ositp/CH6.md)
* 준비 큐 외에도 운영체제는 특정 자원을 기다리는 프로세스들을 줄 세우기 위한 자원별 **장치 큐**를 둔다
* 디스크 컨트롤러는 디스크 입출력 큐에 줄 서 있는 순서대로 프로세스들의 입출력 작업 수행
* 준비 큐, 장치 큐는 하드웨어 지원을 기다리는 프로세스들을 줄 세우기위해 필요한 것 소프트웨어 자원을 기다리는 경우에도 필요
* 프로세스가 공유 데이터를 사용하는 중에 다른 프로세스가 같은 데이터를 접근하면 데이터에 대한 일관성이 훼손
* 공유 데이터는 매 시점 하나의 프로세스만이 접근할 수 있도록 해야 한다
* 공유데이터에 접근 중인 프로세스가 준비 상태나 봉쇄 상태로 변경된 경우에도 새롭게 CPU를 할당받은 프로세스가 동일한 데이터에 접근하게 되면 데이터의 일관성이 깨질 수 있으므로 접근을 허락해서는 안 된다
* 공유 데이터라는 일종의 소프트웨어자원을 앞섯 접근 중인 프로세스가 다 사용하고 반납할 때까지는 다른 프로세스가 CPU를 할당 받았다고 하더라도 접근하지 말고 기다려야 하는 것
* 여러 프로세스가 공유 데이터에 동시에 접근하려고 할 경우 공유 데이터를 기다리는 큐에 줄 서게 하여 현재 그 데이터를 사용하고 있는 프로세스가 데이터를 반납하기 전까지는 접근하지 못하게 하고, 반납할 경우 큐에 줄 서 있는 순서대로 데이터 접근 권한을 주는 방법을 사용
* 프로세스의 상태 관리는 커널의 주소 영역 중 데이터 영역에 다양한 큐를 두어 수행
* 각 프로세스가 CPU를 기다리는지, 입출력을 기다리는지 등의 정보를 커널이 총체적으로 관리
* 작업 큐는 시스템 내의 모든 프로세스를 관리하기 위한 큐, 프로세스의 상태와 무관하게 현재 시스템내에 있는 모든 프로새스가 작업 큐에 속한다
* 작업 큐가 가장 넓은 개념이고 준비 큐와 장치 큐에 있는 프로세스들은 모두 작업 큐에 속해 있다
* 장치 큐는 각각의 자원마다 큐가 하나씩 존재하며, 여기서 큐헤더는 큐의 가장 앞부분
* 큐는 각 프로세스의 PCB를 연결 리스트 형태로 관리하며 포일터를 사용해 순서를 정한다
* 장치 큐에 속한 프로세스들은 봉쇄 상태에 있다가 해당 장치의 서비스를 받고 나서 장치 컨트롤러가 인터럽트를 발생시키면 준비 상태로 바뀌어 준비 큐로 이동
#### 스케줄러
* 스케줄러란? 어떤 프로세스에서 자원을 할당할지를 결정하는 운영체제 커널의 코드
* 장기 스케줄러 - 작업 스케줄러라고고도 부르며, 어떤 프로세스를 준비 큐에 진입시킬지 결정하는 역할
  * 준비 큐는 CPU만 얻으면 당장 실행될 수 있는 프로세스의 집합
  * CPU에서 실행되기 위해서는 프로세스가 메모리를 보유해 하므로 장기 스케줄러는 프로세스에게 메모리를 할당
  * 처음 프로세스가 생성되면 시작 상태를 거쳐 준비 상태에 이르게 되는데 장기 스케줄러는 이때 시작 상태의 프로세스들 중 어떠한 프로세스를 준비 큐에 삽입할 것인지 결정하는 역할
* 단기 스케줄러 - CPU스케줄러라고도 하며, 준비 상태의 프로세스 중에서 어떤 프로세스를 다음번에 실행 상태로 만들 것인지 결정
  * 준비 큐에 있는 여러 프로세스들 중 어떠한 프로세스에게 CPU를 할당할 것인가를 **단기 스케줄러**가 결정
  * 시분할 시스템에서는 타이머 인터럽트가 발생하면 **단기 스케줄러**가 호출
* 스케줄러는 종류에 따라 각각 고유한 특성
  * 단기 스케줄러는 밀리초 정도의 시간 단위로 매우 빈번하게 호출하기 때문에 수행 속도가 충분히 빨라야 한다
  * 장기 스케줄러는 수십 초 내지 수분 단위로 가끔 호출되기 때문에 상대적으로 속도가 느린것이 허용
  * 장기 스케줄러는 메모리에 동시에 올라가 있는 프로세스의 수를 조절하는 역할 이는 시작 상태의 프로세스에게 메모리 할당을 승인할지 여부를 자기 스케줄러가 결정
* 현대의 시분할 시스템에서 사용되는 운영체제에는 일반적으로 장기 스케줄러를 두지 않는 경우가 대부분
* 장기 스케줄러는 과거에 자원이 매우 빈약하던 시절에 주로 사용
* 현대의 시분할 시스템용 운영체제에서는 프로세스가 시작 상태가 되면 장기 스케줄러 없이 곧바로 그 프로세스에 메모리를 할당해 준비 큐에 넣어두게 된다
* 현대의 시분할 시스템용 운용체제에서는 장기 스케줄러 대신 중기 스케줄러를 두는 경우가 많다
* 중기 스케줄러는 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절
* 만약 너무 많은 프로세스가 메모리에 적재되어 프로세스당 보유하고 있는 메모리양이 극도록 적어지면 CPU 수행에 당장 필요한 프로세스의 주소 공간조차도 메모리에 올려놓기 어려운 상항이 발생한다. 그렇게 되면 디스크 입출력이 수시로 발생하게 되어 시스템의 성능이 심각하게 저하
* 중기 스케줄러는 이런 경우 메모리에 올라와 있는 프로세스 중 일부를 선정해 이들로부터 메모리를 통째로 빼앗아 그 내용을 디스크의 스왑 영역에 저장 이와 같은 행위를 **스왑 아웃**
* 중기 스케줄러는 프로세스당 보유 메모리양이 자나치게 적어진 경우 이를 완화시키기 위해 일부 프로세스를 메모리에서 디스크로 스왑 아웃시키는 역활을 수행
* 일부 프로세스를 메모리에서 디스크로 **스왑 아웃**시켜야 하는 경우 그 **0순위**인 프로세스는 **봉쇄상태**에 있는 프로세스
* 봉쇄 상태인 프로세스들의 경우 당장 CPU를 확득할 가능성이 없기 때문에 메모리를 보유하고 있는 것 또한 큰 의미가 없기 때문
* 봉쇄 상태인 프로세스를 모두 스왑 아웃시킨 후에도 메모리 공간이 부족한 경우, 중기 스케줄러는 보통 타이머 인터럽트가 발생해 준비 큐로 이동하는 프로세스를 추가적으로 스왑 아웃
* 준비 큐에 너무 많은 프로세스들이 존재하며 개별 프로세스에 배정되는 메모리양이 지나치게 적어질 뿐 아니라 CPU를 한번 할당받은 후 다시 할당받기까지 오랜 시간이 소요되기 때문에, 이들 프로세스로부터 메모리를 회수해 당장 실행하게 될 프로세스에게 메모리를 추가로 부여하는 것이 더 효율적이기 때문
* 중기 스케줄러는 장기 스케줄러와 마찬가지로 메모리에 올라와 있는 프로세스의 수를 조절하는 역할 수행
* 중기 스케줄러의 등장으로 인해 프로세스의 상태에는 실행, 준비, 봉쇄 외에 하나의 상태가 더 추가
* 외부적인 이유로 프로세스의 수행이 정지된 상태를 나타내는 **중지(suspended, stopped) 상태**
* 중지 상태에 있는 프로세스는 외부에서 재개시키지 않는 이상 다시 활성화될 수 없으므로 메모리 자원이 당장 필요하지 않다
* 중지 상태의 프로세스는 메모리를 통째로 빼앗기고 디스크로 스왑 아웃
* 중기 스케줄러에 의해 디스크로 스왑 아웃된 프로세스의 상태가 대표적인 중지 상태의 예
* 중지상태는 중기준비/중지봉쇄 세분화
* 준비 상태에 있던 프로세스가 스왑아웃되면 중지준비
* 봉쇄 상태에 있던 프로세스가 스왑아웃되면 중지봉쇄
* 중지봉쇄 상태이던 프로세스가 봉쇄되었던 조건을 만족하게 되면 이 프로세스의 사탱는 중지준비 상태로 바뀐다
* 중지 상태에 있는 프로세스들은 중지준비 상태이든 중지봉쇄 상태이든 관계없이 메모리를 조금도 보유하지 않고 디스크에 스왑 아웃된 상태로 존재
#### 프로세스의 생성
* 시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만 그다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성
* 이때 프로세스를 생성하는 프로세스를 부모 프로세스라고 하고, 새롭게 생성된 프로세스를 자식 프로세스
* 프로세스의 세계에서는 자식이 먼저 죽고, 이에 대한 처리를 자식을 생성했던 부무 프로세스가 담당하는 방식으로 진행
* 생성된 프로세스가 작업을 수행하긱 위해서는 자원이 필요
* 자원을 획득하는 방법은 운영체제 및 자원의 종류에 따라 상이하다 어떤 경우에는 운영체제로부터 직접 자원을 할당 또 다른 경우 부모 프로세스와 자원을 공유해서 사용
* 프로세스가 수행되는 모델도 부모와 자식이 공존하며 수행되는 모델과 자식이 종료될 때ㄲ가지 부모가 기다리는 모델
* 부모와 자식이 공존하며 수행된느 모델에서는 자식과 부모가 같이 CPU를 획득하기 위해 경쟁하는 관계
* 부모가 자식의 종료를 기다리는 모델에서는 자식 프로세스가 종료될 때까지 부모 프로세스는 아무 일도 하지 않고 봉쇄 상태에 머물러 있다가, 자식 프로세스가 종료되면 그때 프로세스가 준비 상태갇 되어 다시 CPU를 얻을 권한을 생기게 된다.
* 프로세스가 생성되면 자신만의 독자적인 주소 공간을 가지며 자식 프로세스는 부모 프로세스와는 별도의 주소 공간을 가지게 된다.
* 복사해서 생성한다. 자식 프로세스가 다른 프로그램을 수행하기 위해서는 생성된 주소 공간 위에 새로운 프로그램의 주소 공간을 덮어씌워 실행
* 유닉스 fork()시스템 콜 프로세스 ID를 제외한 모든 정보(운영체제 커널 내의 정보와 주소 공간의 정보)를 그대로 복사는 방법 사용
* fork()를 통해 생성된 자식 프로세스는 exec() 시스템 콜을 통해 새로운 프로그램으로 주소 공간을 덮어씌울 수 있다.
* 프로세스 종료 두 가지
  * 첫 번째는 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려 이루어지는 자발적 종료( 프로세스는 명령을 모두 수행한 후, 프로그램이 마쳐지는 코드 부분에 exit()라는 시스템 콜을 통해 운영체제에게 자신이 종료됨을 알릴 수 있다 이때 종료를 통보받은 운영체제는 이 프로세스로부터 자원을 회수하고 시스템 내에서 이 프로세스를 정리하게된다 한편 exit() 함수는 프로그램 개발자가 명시적으로 호출하지 않아도 프로그램이 종료되는 지점에 컴파일러가 자동으로 삼입해 프로세스의 종류 직전에 항상 호출)
* 두번째는 비자발적 종료로 부모 프로세스가 자식 프로세스의 수행을 강제 종료(abort()라는 함수 통해 이루어지게 된다)
  * 강제종료가 발생하는 경우
    * 자식 프로세스가 할당 자원의 한계치를 넘어서는 많은 양의 자원을 요구할 때
    * 자신 프로세스에게 할당된 작업이 더 이상 필요하지 않을 때
    * 부모 프로세스가 종료(exit)되는 겨우 등
* 종료되는 프로세스의 자식 프로세스를 계속 실행시키기 위해서는 종료되지 않을 다른 프로세스의 양자로 자식 프로세스를 보내어 기존 부모 프로세스가 종료된 후에도 다른 프로세스 아래에서 계속 수행될 수 있도록 하는 것이다. 이러한 방식은을 통해 부모가 죽기 전에 자식이 먼저 죽게 된다는 원칙이 여전히 지켜지는 것이다.
* 자식 프로세스는 부모 프로세스의 처음부터 수행을 시작하는 것이 아니라 부무 프로세스가 현재 수행한 시전(프로그램 카운터 지점)부터 수행
* 운영체제가 프로세스를 관리하기 위해서는 사용자 프로세스 식별자는 부모 프로세스와 다른 식별자를 가지게 된다는 점이 유일한 차이점
* 복제된 프로세스는 자기가 복제본이 아니라 원본이며, 자기를 복제해서 복제본이 생성되었다는 그런 기억을 갖게 된다
* 한가지 이 프로세스가 복제된 프로세스라는 사실을 알 수 있는 단서가 하나 있는데, 그것은 fork() 함수의 결과값으로 원본에서는 양수를 주고 복제본에게는 0을 준다
* fork() 함수 결과값이 다르므로 조건문을 사용해 원본 프로세스와 복제본 프로세스가 다른 작업을 하도록 프로그램을 작성할 수 있다
* 이는 조건문에 의한 분기(branch)일 뿐 사실상 두 프로세스 모두 동일한 코드 내용을 가진다
* 따라서 자식 프로세스에게 부모와 다른 프로그램을 수행시킬 수 있는 매커니즘이 필요 -> exec() 시스템 콜은 프로세스가 지금까지 수행했던 상태를 잊어버리고 그 주소공간을 완전히 새로운 프로그램으로 덮어씌운 후 새로운 프로그램의 첫 부분부터 다시 실행을 시작하도록 하는 시스템 콜
* 새로운 프로그램을 수행시키기 위해서는 fork()를 통해 기존 프로세스와 동일한 프로세스를 복제한 후 exec()을 통해 새롭게 수행시키려는 프로세스를 자식 프로세스의 주소 공간에 덮어씌우면 된다
* 프로세스의 생성과 관련된 fork(), exec() : 특권명령
* 프로세스의 관련된 시스템 콜 fork(), exec(), exit(), wait()
* wait() 시스템 콜은 자식 프로세스가 종료되기를 기다리며 부모 프로세스가 봉쇄 상태에 머무르도록 할 때 사용
* fork() 후 wait() 호출 부모 프로세스는 봉쇄 상태 자식 프로세스가 종료되면 부모를 준비 상태로 변경시켜 작업을 재개
* 아로헌 방식으로 부모 프로세스와 자식 프로세스 간의 동기화가 가능
#### 프로세스 간의 협력
* 프로세스는 각자 자신만의 독립적인 주소 공간을 가지고 수행되며 프로세스가 다른 프로세스의 주소 공간을 참조하는 것을 허용되지 않는다.
* 운영체제는 프로세스 간의 협력 메커니큼을 제공해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있게 한다.
* 프로세스 간의 협력 메커니즘을 위해 운영체제가 제공하는 대표적인 메커니즘으로 **IPC**
* IPC란? 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 같에 발생하는 통신, 의사소통 기능과 함꼐 동기화를 보장
* 하나의 프로세스가 공유 데이터의 값을 변경하는 동안 다른 프로세스는 그 데이터에 접근할 수 없게 해야 한다
* IPC는 프로세스들 간의 통신과 동기화를 이루기 위한 메커니즘
* IPC의 대표적 방법
  * 메세지 전달 방식
  * 공유메모리 방식
  * 두 방식의 차이는 프로세스 사이에 공유 데이터를 사용하는가, 그렇지 않는가에 있다
* 메세지 전달 방식
  * 프로세스 간에 공유 데이터를 일체 사용하지 않고 메시지를 주고받으면서 통신하는 방식
  * 이때 두 프로세스의 주소 공간이 다르므로 메시지 전달을 직접 할 수는 없으며 커널이 그 역할을 하게된다
  * 메시지 통신을 하는 시스템은 커널에 대해 send(message)와 receive(message)라는 두 가지 연산을 제공
  * 이 두연산을 통해 프로세스는 전달할 메시지를 운영체제에게 시스템 콜 방식으로 요청해 전달
  * 메시지를 프로세스끼리 직접 주고받을 수 있다면 원하지 않는 메시지를 전달해 다른 프로세스에 악영향을 미칠 수 있으므로 운영체제는 메시지를 주고받는 연산은 특권명령으로 규정해 커널을 통해서만 가능
  * 통신하기 원하는 두 프로세스는 커뮤니케이션 링크를 생성한 후 send()와 recive()를 이용해서 메시지를 주고받게 된다
  * 커뮤니케이션 링크의 구현 방법은 물리적인 방법과 논리적인 방법
  * 메시지 전달을 통해 통신하는 방식은 메시지의 전송 대상이 다른 프로세스인지 아니면 메일박스라는 일종의 저장공간인지에 따라 다시 **직접통신**과**간접통신**
  * 두 가지 방식의 차이는 연산의 인터페이스에 대한 차이일 뿐 실제 메시지 전송이 이루어지는 내부 구현은 커널의 중재에 의해 사실상 동일한 방식으로 이루어 진다
  * 직접 통신 : 통신하려는 프로세스의 이름을 명시적으로 표시, 커뮤니케이션 링크는 자동적으로 생성되고, 하나의 링크는 정획히 한 쌍의 프로세스에게 할당
  * 각 쌍의 프로세스에게는 오직 하나의 링크만 존재하고, 링크는 단방향서일 수 있으나 대부분의 경우 양방향성
  * 간접 통신 : 메일박스또는 포트로부터 전달
  * 각 메일박스에는 고유의 ID가 있으며 메일박스를 공유하는 프로세스들만 서로 통신을 할 수 있다.
  * 간접통신에서 사용되는 커뮤니케이션 링크는 프로세스 간에 메일박스를 공유하는 경우에만 생성, 하나의 링크가 여러 프로세스들에게 할당될 수 있으며 각 프로세스의 쌍은 여러 링크를 공유(단방향성 또는 양방향성)
  * 간접통신에서는 새로운 메일박스를 생성하는 연산, 메일박스를 통한 메시지의 send()/receive() 연산, 메일박스를 삭제하는 연산 등이 사용
  * 2개의 프로세스에게만 링크를 할당, 링크에 대한 recive() 연산을 매 시점 하나의 프로셋스만 수행할 수 있도록 하는 방법
  * 그렇지 않으면 시스템이 메시지 수신자를 임의로 결정해 누가 메시지를 받았는지 송신자에게 통신해주는 방식이 사용될 수 있다
* 공유 메모리
  * 프로세스들이 주소 공간의 일부를 공유
  * 운영체제는 공유 메모리를 사용하는 시스템 콜을 지원
  * 서로 다른 프로세스들이 그들의 주소 공간 중 일부를 공유
  * 공유메모리 영역은 각자의 주소 공간에 공통적으로 포함되는 영역
  * 여러 프로세스가 읽고 쓰는 것이 가능
  * 이 주소 공간이 물리적 메모리에 매핑될 때 공유메모리 주소 영역에 대해서는 동일한 물리적 메모리 주소로 매핑
  * 공유 메모리 방식은 프로세스간의 통신을 수월하게 만드는 인터페이스를 제공하지만 서로의 데이터에 일관성 문제 유발
  * 커널이 책임지지 않기 때문에 프로세스들끼리 직접 공유메모리 접근에 대한 동기화 문제를 책임
