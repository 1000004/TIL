### ch 2 운영체제 개요
#### 운영체제란?   
- 컴퓨터 하드웨어 바로 윗단에 설치하는 소프트웨어   
- 각종 소프트웨어들은 하드웨어와 운영체제가 한 몸으로 존재하는 컴퓨터 시스템 위에서 수행되는 것으로 볼수 있다
- 전원이 켜지면 메모리에 운영체제의 커널이 올라간다
#### 운영체제 기능
* 하드웨어 쪽에서는 사용자가 직접 다루기 힘든 각종 하드위어를 운영체제가 관리하며, 사용자에게는 편리한 인터페이스 제공
* 주요 기능 컴퓨터 시스템 내의 자원을 효율적으로 관리, 컴퓨터를 편리하게 사용할 수 있는 환경 제공
* **핵심 기능** 컴퓨터 내의 자원을 효율적으로 관리(운영체제를 자원관리자라고 부르기도 한다) 가장 좋은 성능을 내도록하는 역할
* (자원이란? CPU,메모리,하드디스크 등 하드웨어 자원뿐 아니라 소프트웨어 자원까지 통칭)
* **효률성**이 가장 큰 목표이지만 이로 인해 일부가 지나치게 희생되지 않게하는 **형평성** 역시 운영체제가 고려해야 하는 목표
* 보안 및 보호 기능 수행
#### 운영체제의 분류
* #### 동시작업 지원 여부 단일작업/다중작업
* CPU의 작업시간을 여러 프로그램들이 조금씩 나누어 쓰는 시스템을 시분할 시스템
* 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템을 다중 프로그램 시스템
* 사용자 개개인의 관점에서는 각 프로그램에 대한 키보드 입력의 결과를 곧바로 화면에 보여주기 때문에 이러한 시스템 대화형 시스템
* **다중작업, 시분할, 다중 프로그래밍, 대화형 시스템**은 모두 여러 프로그램이 하나의 컴퓨터엣서 동시에 실행 
* ->CPU가 하나뿐인 컴퓨터인 경우 해당 성질
* 다중처리기 시스템은 하나의 컴퓨터 안에 CPU가 여러 개 설치된 경우 의미 프로그램이 동시 실행 여러 CPU를 관리하기 위해 더욱 복잡한 메커니즘
* #### 다중사용자에 대한 동시지원 여부
* #### 자업을 처리하는 방식 일괄처리/시분할 방식
* 사용자의 요청에 대한 결과를 곧바로 얻을 수 있는 시스템을 ***대화형 시스템***이라고 표현 이는 ***시분할 방식의 대표적인 특징***
* #### 실시간 운영체제 정해진 시간 안에 어떠한 일이 반드시 처리됨을 보장
* 경성 실시간 시스템 주어진 시간 지키지 못할 경우 매우 위험한 결과 초래
* 연성 실시간 시스템 멀티미디어 스트리밍 시스템과 같이 데이터가 정해진 시간 단위로 전달 되어야 올바른 기능 수행 위험 결과 초래하지 않는다
#### 운영체제의 예
* **윈도우** XP부터는 인터페이스 측면에서 그래픽 환경과 아이콘 방식을 기본적으로 채택하면서 동일한 명령어라도 수행하는 방식을 여러 가지로 지원해 누구나 편한 방법으로 다룰 수 있게 하고 있다
* MS 윈도우의 시스템에 새로운 하드웨어를 장착하면 운영체제가 자동으로 하드웨어 감지(플러그 앤 플레이)
* 유닉스보다 안정성 떨어짐/사용이 편리한 여러 가지 기능을 제공 일반 사용자에게 보편/최근 안전성 상당히 개선/웹서버 등 다중 사용자용  운영체제로 사용된느 버전 NT
* **유닉스** 프로그램 개발 환경을 위해 설계된 운영체제 **이식성**이 좋고 운영체제 커널 크기가 작으면, 소스코드가 공개되었다.
* 갈끔한 모듈 단위로 작성 운영체제 하드웨어 기술이나 소프트웨어 기술이 발전하더라도 **확장성** 지원
* 소프트웨어의 이식성? 해당 소프트웨어를 다른 기종의 기계로 옮기는 것이 얼마나 용이한가를 나타내는 지표
* 초기 유닉스 운영체제의 핵심 부분이라 할 수 있는 커널의 크기가 놀라운 만큼 작으며 여러 유틸리티 지원 프로그램 환경에는 이상적
* 고급언어로 작성된 유닉스(C언어) 이해가 쉽고 다른 기종에 이식하는 것이 훨씬 쉬워졌다
* 최근 리눅스의 등장으로 대형 서버뿐 아니라 개인용 컴퓨터에서도 유닉스를 널리 사용
#### 운영체제의 지원 관리 기능
> 운영체제의 핵심기능 자원 효율적 관리
* 하드웨어 자언/소프트웨어 자원
* 하드웨어 CPU와 메모리를 비롯해 주변장치 또는 입출력 장치라 불리는 장치 구성
  * 프로세스들이 CPU를 효율적으로 나누어 사용
  * 메모리 한정된 용량 존재 서로 다른 다수의 프로세스를 나누어 쓸 수 있다
  * 입출력장치도 운영체제의 관리 필요
  * CUP와 메모리는 꺼지면서 처리 중이던 정보 지워짐 
  * -> 전원이 나가도 기억하도록 보조기억장치에 파일 형태로 저장 (대표적인 매체 하드디스크)
  * -> 파일들이 저장되는 방식 및 접근 권한 등에 대해서도 운영체제가 관리
* #### CPU 관리하는 방법
  * CPU 스케줄링 : 매 시점 어떠한 프로세스에 CPU를 할당해 작업을 처리할 것인지 결정 필요
  * CPU 스케줄링 목표 : CPU를 가장 효율적으로 사용하면서도, 특정 프로세스가 불익을 당하지 않도록 하는것
  * CPU 스케줄링 종류
    * 선입선출 기법 : CPU를 사용하기 위해 도착한 프로세스들 중 먼저 온것을 먼저 처리
      * CPU를 먼저 얻은 프로세스가 원하느 작업을 완료할 때까지 다른 프로세스들은 CPU 사용을 못한다
      * CPU 자체 효율적인 사용 측면에서는 문제가 없지만 전체 시스템 입장에서는 비효율적인 결과 초래
      * 이러한 단점을 보안한 **라운드 로빈**
    * 라운드 로빈 : CPU를 한번에 할당받아 사용할 수 있는 시간을 일정하게 고정된 시간으로 제한
      * 일반적으로 1회 할당 시간은 밀리초 단위 사용
      * 다수의 사용자가 동시에 접속할 때에도 각자 1초 이하의 응답시간 보장
    * 우선순위 스케줄링 : 대기 중인 프로세스들에 우선 순위를 부여 우선순위가 높은 프로세스에 CPU를 먼저 할당
      * 지나치게 오래 기다리는 프로세스가 발새하지 않도록, 기다린 시간이 늘어날수록 우선순위를 점차 높여주는 방안도 우선순위 스케줄링에 활용
* #### 메모리 관리하는 방법
  * 메모리 : CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억장치
  * 프로그램이 CPU에서 실행되려면 해당 부분이 메모리에 올라가 있어야 한다.
  * 주소를 통해 관리
  * 메모리를 조금만 더 할당하면 굉장히 빠르게 수행 불필요하게 메모리를 요청시 자원 낭비 
  * -> 운영체제는 이를 잘 판단해 전체 메모리 공간이 효율적으로 사용될 수 있도록 새야 한다.
  * 다수의 사용자 프로그램이 동시에 메모리에 올라간 경우 서로 다른 프로세스의 영역을 침범하지 않도록 보안을 유지하는 것도 운영체제 역할
  * 즉 운영체제는 각 프로세스가 자신의 메모리 영역에만 접근하도록 관리
* #### 물리적 메모리 관리하는 방법
  * **고정분할, 가변분할, 가상메모리**
  * 고정분할 방식 : 물리적 메모리를 몇 개의 분할로 미리 나누어 관리 -> 융통성 없다
    * 동시 적제된느 초대 프로그램 수가 분할 개수로 한정/분할의 크기보다 큰 프로그램 적재 불가능 -> 메모리 효율적인 사용 측면에서도 바람직하지 않다.
    * 내부조각 발생 : 해당분할에 올라온 프로그램에 의해서 사용되지 않고, 다른 프로그램에도 할당될 수 없으므로 비효율적으로 낭비되는 공간 생성
  * 가변불할 방식 : 매 시점 프로그램의 크기에 맞겍 메모리 분할하여 사용하는 방식
    * 물리적 메모리의 크기보다 더 큰 프로그램 실행 여전히 불가능
    * 분할의 크기와 갯수가 동적으로 변하므로 기술적 관리 기법 필요
    * 외부조각 발생 : 프로그램에 할당되지는 않지만 그 크기가 작아 프로그램을 올리지 못하는 메모리 영역
    * 현재 비어 있는 공간이지만 그 크기각 작아 아직까지 프로그램에 할당되지 못한 공간을 의미 외부조작 역시 낭비된 메모리 자원
  * 가변메모리 기법: 물리적 메모리보다 더 큰 프로그램이 실해되는 것을 지원 실행될 수 있는 프로그램의 크기는 가상메모리의 크기에 의해 결정
    * 모든 프로그램은 자신만의 가상 메모리 주소를 가진다
    * 운영체제는 이 가상 메모리의 주소를 물리적 메모리 주소로 매핑하는 기술을 이용해 주소 변환시킨 후 프로그램을 물리적 메모리에 오림
    * 프로그램의 전체가 커도 전체가 항상 동시에 사용되는 것은 아니다
    * 현재 사용되고 있는 부분만 메모리에 올리고, 나머지는 하드디스크와 같은 보조기억장치에 저장해두었다가 필요할 때 적재
    * 이때 사용된느 보조기억장치의 영역 : 스왑 영역
    * 프로그램을 구성하는 가상메모리 주소 공간은 페이지라는 동일한 크기의 작은 단이로 누뉘어 물리적 메모리와 수왑 영역에 일부분씩 저장
    * 동일한 단위로 메모리를 나누는 기법 : 페이징 기법
 * #### 주변장치 및 입출력 장치 관리하는 방법
   * 인럽트라는 메커니즘을 통해 관리
   * 주변장치들은 CPU의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청, 이때 발생시키는 신호를 **인터럽트**
   * 인터럽트가 발생했을 때에도 직전의 작업 상태를 잠시 저장해두고 인터럽트를 먼저 처리
   * 운영체제는 인터럽트의 종류마다 서로 다른 인터럽트 저리 루틴을 가진다
   * 인터럽트 처리루틴 : 인터럽트가 발생했을 때 해주어야 할 작업을 정의한 프로그램 코드
   * 운영체제 커널 내에 존재하는 코드 CPU 스케줄링, 메모리 관리 등 다양한 기능을 위한 커널 코드의 일부
   * 인터럽드(**interrupt**)가 발생한면 운영체제는 해당 인터럽트 처리루틴을 찾아서 정의된 코드에 따라 일을 수행
   * 주변장치들은 각 장치마다 그 장치에서 일어나는 업무를 관리하기 위한 일종의 작은 CPU를 가진다 : 컨트롤러(controllor, 제어기)
   * 컨트롤러는 해당 장치에 대한 업무를 처리하고, 이를 메인CPU에 인터럽트를 발생시켜 보고하는 역할
   * 주변장치들은 이와 같이 인터럽트를 통해서 CPU의 서비를 받는다.  
    For Example 키보드에 의해 인터럽트가 발생한 경우라면 사용자의 입력 데이터를 해당 프로그램에 전달하는 절차를 수행 인터럽트 처리 완료한 후에는 원래 하던 일을 계속 수행
