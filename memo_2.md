객체지향 양방향 A가 B의 참조 B가 A의 참조
데이터베이스에 특정한 PK를 다른 테이블에서 FK로 참조해서 사용
JPA는 객체지향을 통해서 관계형 데이터 베이스를 처리하므로 참조를 결정할 때 다양한 방식 존재
단방향/양방향
* 양방향의 경우 양쪽 객체 모두를 변경해 주어야 하기 때문에 구현할 때도 주의해야 하지만 트랜잭션을 신경 써야만 한다
* list.html 목록에 댓글을 표시하기 위해 BoardListReplyCountDTO
* Projecions.bean 한번에 DTO로 처리
* CustomRestAdvice
  *  @ExceptionHandler
* @PathVariable라는 어노테이션을 이용해서 호출하는 **경로의 값**을 직접 파라미터의 변수를 처리할 수 있는 방법 제공  
Axios - 액시오스
* Promise는 프로미스가 생성된 시점에는 알려지지 않았을 수도 있는 값을 위한 대리자로, 비동기 연산이 종료된 이후에 결과 값과 실패 사유를 처리하기 위한 처리기를 연결할 수 있습니다. 프로미스를 사용하면 비동기 메서드에서 마치 동기 메서드처럼 값을 반환할 수 있습니다. 다만 최종 결과를 반환하는 것이 아니고, 미래의 어떤 시점에 결과를 제공하겠다는 '약속'(프로미스)을 반환합니다.
* read.html에서는 주로 이벤트 관련된 부분 처리하도록 하고 별도의 JS 파일을 작성해서 Axios를 이용하는 통신을 처리하도록 구성
* @JsonFormat
* @JsonIgnore
* printReplies(1,10,true)
* 만일 댓글이 많지 않아서 새로 데이터를 가져올 필요가 없는 경우에는 추가적인 호출을 하지 않게 됩니다.
* 로그 레벨 조정
* BCrypPasswordEncoder는 해시 알고리즘으로 암호화 처리되는데 같은 문자열이라고 해도 해시 처리된 결과가 다르므로 패스워드 암호화에 많이 사용
* @Valid 과정에서 문제가 있는 필드들과 메시지를 JSON 문자열로 전송  
* 인증 인가
* 웸 애플리케이션에서 스프링 시큐리티를 적용하면 로그인을 통해서 '인증'을 수행하고 컨트롤러의 경로에 시큐리티 설정으로 특정한 권한이 있는 사용자들만 접근할 수 있도록 설정
* 스프링 시큐리티의 동작 방식은 웨에서 로그인 처리로 아이디와 패스워드를 한번에 조회하는 방식과 달리 아이디(username)만을 이용해서 사용자 정보를 로딩하고 나중에 패스워드를 검증하는 방식
* 인증 처리는 인증 제공자라는 존재를 이용해서서 처리되는데 인증 제공자와 그 이하의 흐름은 일반적으로 커스터마이징해야 하는 경우가 거의 없으므로 실제 인증 처리를 담당하는 객체만을 커스터마이징하는 경우가 대부분
* passwordEncoder() - PasswordEncoder 타입 반환 (패스워드 암호화)
* 스프링 시큐리티는 기본적으로 GET방식을 제외한 PSOT/PUT/DELETE 요청에 CSRF 토큰 요구 - 에러발생
* CSRF 토큰이란, 'Cross-Site Request Forgery(크로스 사이트 간 요청 위조)'의 약어로 권한이 있는 사용자가 자신도 모르게 요청을 전송하는 공격방식
* CSRF 토튼 비활성화
* CSRF 토큰은 사용자가 사이트를 이용할 때 매번 변겨되는 문자열을 생성하고 이를 요청 시에 검증하는 방식
* 문자열이 변경되기 때문에 해당 문자열을 알지 못하면 A에서는 요청을 처리하지 않도록 한다
* http.formLogin().loginPage("/member/login");와 같이 지정하면 POST 방식 처리 역시 같은 경로로 스프링 시큐리티 내부에서 처리
* persistentTokenRepository()라는 메소드를 이용해 처리
 * remember-me 쿠키를 생성할 때는 쿠키의 값을 인코딩하기 위한 키(key)값과 필요한 정보를 저장하는 tokenRepository를 지정
* Thymeleaf Extras Springsecurity5 라이브러리 추가
 * Thymeleaf에서 인증 정보를 처리하기 위해서는 Thymeleaf에서 스프링 시큐리티를 사용하기 위한 라이브러리를 이용
 * 게시물 조회 BoardController에서 로그인한 사용자만 조회할 수 있도록 수정 - @PreAuthorize("isAuthenicated()")
 * 인증 정보를 통해 본인이 작성한 게시글만 Modify button 존재
 * @PreAuthorize("isAuthenicated()")인 경우 사용자 로그인이 안 되었다면 302 메시지와 함께 호긍니 경로로 이동하지만 403 에러는 앞의 그림과 같이 에러가 발생
  * 403 사용자 권한이 없는경우/특정 조건이 맞지 않는 경우
 * ????????/Handler
* REST API를 사용한 로그인 구현
* AuthenticationSucessHandler
* 브라우저에 필요한 화면의 모든 코드(HTML)를 서버에서 만들어 전송하는 방식을 **서버 사이드 렌더링(Server Side Rendering 이하 SSP)**
* API 서버는 화면 구성은 별도의 클라이언트 프로그램에서 처리하고 서버에서는 순수한 데이터만 전송하게 됩니다. 이러한 구성을 '클라이언트 사이트 렌더링'이라고 합니다
* API 서버의 특징
 * 화면을 구성하지 않는다
 * 무상태 - REST나 HTTP의 특징
* API 서버는 단순히 요청과 응답에서 발생한 부수적인 결과를 유지하지 않는다.
* 토큰 기반의 인증 - 특정한 사용자나 프로그램에서만 API 서버를 호출할 수 있도록 제한
* 인증을 위한 프로젝트 구성
 * 스프링 시큐리티의 필터를 이용해서 토큰들을 검사 - 서블릿의 필터(Filter)와 유사하지만 스프링의 빈들을 사용할 수 있다는 장점
 * 화면 구성이 필요하지 않으므로 Thymeleaf를 사용하지 않음
 * 자동으로 세션/쿠키를 생성하지 않음(무상태로 처리)
 * JWT 문자열을 생성해서 토큰으로 사용
* **안증** '스스로를 증명하다' 인증을 위해 아이디나 패스워드 제공
* **인가** '허가나 권한' 인증된 사용자라고 해도 이에 접근하는 권한이 있는지 확인 하는 과정
* CSRF
* CORS
